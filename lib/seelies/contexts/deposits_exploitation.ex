defmodule Seelies.UnitStartedExploitingDeposit do
  @derive Jason.Encoder
  defstruct [:game_id, :unit_id, :deposit_id, :time]

  def apply(game = %Seelies.Game{exploitations: exploitations}, %Seelies.UnitStartedExploitingDeposit{unit_id: unit_id, deposit_id: deposit_id, time: time}) do
    exploitation = %{unit_id: unit_id, last_resolution_at: time, deposit_id: deposit_id}
    %{game | exploitations: Map.put(exploitations, unit_id, exploitation)}
  end
end



defmodule Seelies.UnitStartsExploitingDeposit do
  defstruct [:game_id, :unit_id, :deposit_id, :time]

  def execute(%Seelies.Game{game_id: game_id, units: units, exploitations: exploitations, board: board}, %Seelies.UnitStartsExploitingDeposit{unit_id: unit_id, deposit_id: deposit_id, time: time }) do
    cond do
      units[unit_id] == nil ->
        {:error, :unit_not_found}

      exploitations[unit_id] != nil ->
        {:error, :already_exploiting_deposit}

      units[unit_id].convoy_id != nil ->
        {:error, :unavailable_unit}

      not Seelies.Board.has_deposit?(board, deposit_id) ->
        {:error, :deposit_not_found}

      not Seelies.Board.is_deposit_in_range?(board, deposit_id, units[unit_id].territory_id) ->
        {:error, :deposit_is_too_far}

      true ->
        %Seelies.UnitStartedExploitingDeposit{game_id: game_id, unit_id: unit_id, deposit_id: deposit_id, time: time}
    end
  end
end



defmodule Seelies.UnitStoppedExploitingDeposit do
  @derive Jason.Encoder
  defstruct [:game_id, :unit_id, :time]

  def apply(game = %Seelies.Game{units: units, exploitations: exploitations, territories: territories, board: board}, %Seelies.UnitStoppedExploitingDeposit{unit_id: unit_id, time: time}) do
    territory_id          = units[unit_id].territory_id
    deposit_id            = exploitations[unit_id].deposit_id
    deposit_type          = board.deposits[deposit_id].type
    resources_per_second  = Seelies.Unit.resources_per_second(units[unit_id].species, deposit_type)
    exploitation_duration = time - exploitations[unit_id].last_resolution_at
    earned_resources      = %{deposit_type => resources_per_second * exploitation_duration}

    %{game |
      exploitations: Map.delete(exploitations, unit_id),
      territories: update_in(territories, [territory_id, :resources], fn (stored_resources) -> Seelies.ResourcesQuantity.add(stored_resources, earned_resources) end)
    }
  end
end



defmodule Seelies.UnitStopsExploitingDeposit do
  defstruct [:game_id, :unit_id, :time]

  def execute(%Seelies.Game{game_id: game_id}, %Seelies.UnitStopsExploitingDeposit{unit_id: unit_id, time: time }) do
    %Seelies.UnitStoppedExploitingDeposit{game_id: game_id, unit_id: unit_id, time: time}
  end
end



defmodule Seelies.DepositsExploitationTicked do
  @derive Jason.Encoder
  defstruct [:game_id, :time]

  def apply(game = %Seelies.Game{exploitations: exploitations, units: units, board: board, territories: territories}, %Seelies.DepositsExploitationTicked{time: time}) do
    {resources_earned_by_territory, new_exploitations} = Enum.reduce(exploitations, {%{}, exploitations}, fn ({unit_id, exploitation}, {resources_earned_by_territory, new_exploitations}) ->
      territory_id          = units[unit_id].territory_id
      deposit_type          = board.deposits[exploitation.deposit_id].type
      resources_per_second  = Seelies.Unit.resources_per_second(units[unit_id].species, deposit_type)
      exploitation_duration = time - exploitation.last_resolution_at
      earned_resources      = %{deposit_type => resources_per_second * exploitation_duration}

      {
        Map.update(resources_earned_by_territory, territory_id, earned_resources, fn (already_earned_resources) -> Seelies.ResourcesQuantity.add(already_earned_resources, earned_resources) end),
        Map.put(new_exploitations, unit_id, Map.put(exploitation, :last_resolution_at, time))
      }
    end)

    new_territories = Enum.reduce(resources_earned_by_territory, territories, fn ({territory_id, resources}, new_territories) ->
      put_in(new_territories, [territory_id, :resources], Seelies.ResourcesQuantity.add(game.territories[territory_id].resources, resources))
    end)

    %{game | exploitations: new_exploitations, territories: new_territories}
  end
end


defmodule Seelies.DepositsExploitationTicks do
  defstruct [:game_id, :time]

  def execute(%Seelies.Game{game_id: game_id}, %Seelies.DepositsExploitationTicks{time: time}) do
    %Seelies.DepositsExploitationTicked{game_id: game_id, time: time}
  end
end
